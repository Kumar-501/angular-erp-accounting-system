// add-expense.component.ts

import { Component, OnInit, OnDestroy } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { LocationService } from '../services/location.service';
import { ExpenseCategoriesService } from '../services/expense-categories.service';
import { UserService } from '../services/user.service';
import { CustomerService } from '../services/customer.service';
import { Router } from '@angular/router';
import { firstValueFrom, Observable, Subscription } from 'rxjs';
import { TaxService } from '../services/tax.service';
import { AccountService } from '../services/account.service';
import { ExpenseService } from '../services/expense.service';
import { Firestore } from '@angular/fire/firestore';

@Component({
  selector: 'app-add-expense',
  templateUrl: './add-expense.component.html',
  styleUrls: ['./add-expense.component.scss']
})
export class AddExpenseComponent implements OnInit, OnDestroy {
  expenseForm!: FormGroup;
  maxFileSizeMB = 5;
  allowedFileTypes = ['pdf', 'csv', 'zip', 'doc', 'docx', 'jpeg', 'jpg', 'png'];
  selectedFile: File | null = null;
  businessLocations: any[] = [];
  taxRates: any[] = [];
  paymentAccounts: any[] = [];
  expenseCategories: any[] = [];
  incomeCategories: any[] = [];
  users: any[] = [];
  customers: any[] = [];
  accountHeads: any[] = [];
  
  private locationsSubscription: Subscription | undefined;
  private expenseCategoriesSubscription: Subscription | undefined;
  private incomeCategoriesSubscription: Subscription | undefined;
  private usersSubscription: Subscription | undefined;
  private customersSubscription: Subscription | undefined;
  autoGeneratedRefNo: string = '';
  displayRefNumber: string = '';
  isSubmitting: boolean = false;
  
  // NEW: Add balance and payment status properties
  balanceAmount: number = 0;
  paymentStatus: string = 'Paid';
  
  constructor(
    private fb: FormBuilder, 
    private taxService: TaxService,
    private accountService: AccountService,
    private expenseService: ExpenseService,
    private locationService: LocationService,
    private expenseCategoriesService: ExpenseCategoriesService,
    private userService: UserService,
    private customerService: CustomerService,
    private router: Router,
    private firestore: Firestore
  ) {}

  ngOnInit(): void {
    this.initForm();
    this.loadBusinessLocations();
    this.loadExpenseCategories();
    this.loadIncomeCategories();
    this.loadUsers();
    this.loadCustomers();
    this.loadTaxRates();
    this.loadPaymentAccounts();
    this.generateReferenceNumber();
    
    this.expenseForm.get('referenceNo')?.valueChanges.subscribe(value => {
      if (!value || value.trim() === '') {
        this.updateRefNumberPlaceholder();
      }
    });
    
    // Setup listeners for automatic calculations
    this.expenseForm.get('totalAmount')?.valueChanges.subscribe(() => {
      this.recalculateFromTotalAmount();
    });

    this.expenseForm.get('finalAmount')?.valueChanges.subscribe(() => {
      this.recalculateFromFinalAmount();
    });
    
    this.expenseForm.get('applicableTax')?.valueChanges.subscribe(() => {
      this.recalculateFromTotalAmount();
    });
    
    // NEW: Add listeners for payment amount and final amount changes
    this.expenseForm.get('paymentAmount')?.valueChanges.subscribe(() => {
      this.calculateBalance();
    });
    
    this.expenseForm.get('finalAmount')?.valueChanges.subscribe(() => {
      this.calculateBalance();
    });
  }

  // NEW: Add method to calculate balance and payment status
  calculateBalance(): void {
    const finalAmount = parseFloat(this.expenseForm.get('finalAmount')?.value || 0);
    const paymentAmount = parseFloat(this.expenseForm.get('paymentAmount')?.value || 0);
    
    this.balanceAmount = finalAmount - paymentAmount;
    
    // Determine payment status
    if (paymentAmount >= finalAmount) {
      this.paymentStatus = 'Paid';
    } else if (paymentAmount > 0) {
      this.paymentStatus = 'Partial';
    } else {
      this.paymentStatus = 'Due';
    }
    
    // Update the form control
    this.expenseForm.get('paymentStatus')?.setValue(this.paymentStatus, { emitEvent: false });
  }

  private recalculateFromTotalAmount(): void {
    const totalAmountValue = this.expenseForm.get('totalAmount')?.value;
    if (!totalAmountValue) {
      this.expenseForm.get('taxAmount')?.setValue('0.00', { emitEvent: false });
      this.expenseForm.get('finalAmount')?.setValue('', { emitEvent: false });
      return;
    }
  
    const taxId = this.expenseForm.get('applicableTax')?.value;
    const totalAmount = parseFloat(totalAmountValue);
    let taxRate = 0;
    
    if (taxId && taxId !== 'None') {
      const selectedTax = this.taxRates.find(tax => tax.id === taxId);
      if (selectedTax?.rate) {
        taxRate = parseFloat(selectedTax.rate) / 100;
      }
    }
    
    const taxAmount = totalAmount * taxRate;
    const finalAmount = totalAmount + taxAmount;
    
    this.expenseForm.get('taxAmount')?.setValue(taxAmount.toFixed(2), { emitEvent: false });
    this.expenseForm.get('finalAmount')?.setValue(finalAmount.toFixed(2), { emitEvent: false });
    
    // NEW: Recalculate balance after final amount changes
    this.calculateBalance();
  }
  
  private recalculateFromFinalAmount(): void {
    const finalAmountValue = this.expenseForm.get('finalAmount')?.value;
    if (!finalAmountValue) {
      this.expenseForm.get('taxAmount')?.setValue('0.00', { emitEvent: false });
      this.expenseForm.get('totalAmount')?.setValue('', { emitEvent: false });
      return;
    }
  
    const taxId = this.expenseForm.get('applicableTax')?.value;
    const finalAmount = parseFloat(finalAmountValue);
    let taxRate = 0;
  
    if (taxId && taxId !== 'None') {
      const selectedTax = this.taxRates.find(tax => tax.id === taxId);
      if (selectedTax?.rate) {
        taxRate = parseFloat(selectedTax.rate) / 100;
      }
    }
  
    const totalAmount = finalAmount / (1 + taxRate);
    const taxAmount = finalAmount - totalAmount;
  
    this.expenseForm.get('totalAmount')?.setValue(totalAmount.toFixed(2), { emitEvent: false });
    this.expenseForm.get('taxAmount')?.setValue(taxAmount.toFixed(2), { emitEvent: false });
    
    // NEW: Recalculate balance after final amount changes
    this.calculateBalance();
  }

  ngOnDestroy() {
    if (this.locationsSubscription) this.locationsSubscription.unsubscribe();
    if (this.expenseCategoriesSubscription) this.expenseCategoriesSubscription.unsubscribe();
    if (this.incomeCategoriesSubscription) this.incomeCategoriesSubscription.unsubscribe();
    if (this.usersSubscription) this.usersSubscription.unsubscribe();
    if (this.customersSubscription) this.customersSubscription.unsubscribe();
  }

  loadUsers() {
    this.usersSubscription = this.userService.getUsers().subscribe(
      (users: any[]) => {
        this.users = users;
      },
      (error: any) => console.error('Error loading users:', error)
    );
  }

  loadCustomers() {
    this.customersSubscription = this.customerService.getCustomers().subscribe(
      (customers: any[]) => {
        this.customers = customers.filter(customer => 
          customer.status === 'Active'
        );
      },
      (error: any) => console.error('Error loading customers:', error)
    );
  }

  loadTaxRates() {
    this.taxService.getTaxRates().subscribe(
      (rates: any[]) => {
        this.taxRates = rates;
      },
      (error: any) => console.error('Error loading tax rates:', error)
    );
  }

  async loadPaymentAccounts(): Promise<void> {
    try {
      const accounts = await firstValueFrom(
        new Observable<any[]>(observer => {
          const unsub = this.accountService.getAccounts((accounts: any[]) => {
            observer.next(accounts);
            observer.complete();
          });
          return () => unsub();
        })
      );

      this.paymentAccounts = await Promise.all(
        accounts.map(async (account) => {
          const calculatedBalance = await this.accountService.getCalculatedBalance(account.id);
          return {
            id: account.id,
            name: account.name,
            accountType: account.accountType,
            balance: calculatedBalance,
            openingBalance: account.openingBalance
          };
        })
      );

      console.log('Payment accounts loaded with accurate, calculated balances:', this.paymentAccounts);
    } catch (error) {
      console.error('Error loading payment accounts:', error);
      this.paymentAccounts = [];
    }
  }

  loadBusinessLocations() {
    this.locationsSubscription = this.locationService.getLocations().subscribe(
      (data: any[]) => {
        this.businessLocations = data;
      },
      (error: any) => console.error('Error loading business locations:', error)
    );
  }

  loadExpenseCategories() {
    this.expenseCategoriesSubscription = this.expenseCategoriesService.getExpenseCategories().subscribe(
      (data: any[]) => {
        this.expenseCategories = data;
        this.extractAccountHeads([...this.expenseCategories, ...this.incomeCategories]);
      },
      (error: any) => console.error('Error loading expense categories:', error)
    );
  }

  loadIncomeCategories() {
    this.incomeCategoriesSubscription = this.expenseCategoriesService.getIncomeCategories().subscribe(
      (data: any[]) => {
        this.incomeCategories = data;
        this.extractAccountHeads([...this.expenseCategories, ...this.incomeCategories]);
      },
      (error: any) => console.error('Error loading income categories:', error)
    );
  }

  extractAccountHeads(categories: any[]) {
    const uniqueAccountHeadsSet = new Set<string>();
    
    categories.forEach(category => {
      if (category.accountHead && category.accountHead.trim() !== '') {
        uniqueAccountHeadsSet.add(category.accountHead);
      }
    });
    
    this.accountHeads = Array.from(uniqueAccountHeadsSet).map(head => ({
      value: head,
      name: head
    }));
  }

  generateReferenceNumber() {
    const date = new Date();
    const year = date.getFullYear().toString().slice(-2);
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    const random = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
    
    const typePrefix = this.expenseForm?.get('type')?.value === 'income' ? 'INC' : 'EXP';
    this.autoGeneratedRefNo = `${typePrefix}-${year}${month}${day}-${random}`;
    this.displayRefNumber = this.autoGeneratedRefNo;
    
    setTimeout(() => this.updateRefNumberPlaceholder(), 100);
  }
  
  updateRefNumberPlaceholder() {
    const refNoInput = document.getElementById('referenceNo') as HTMLInputElement;
    if (refNoInput) {
      refNoInput.placeholder = this.autoGeneratedRefNo;
    }
  }

  initForm(): void {
    this.expenseForm = this.fb.group({
      type: ['expense', Validators.required],
      businessLocation: ['', Validators.required],
      expenseCategory: [''],
      incomeCategory: [''],
      subCategory: [''],
      expenseType: [''],
      incomeType: [''],
      accountHead: [''],
      referenceNo: [''],
      date: [new Date().toISOString().slice(0, 16), Validators.required],
      expenseFor: [''],
      incomeFor: [''],
      expenseForContact: [''],
      incomeForContact: [''],
      document: [null],
      applicableTax: ['None'],
      totalAmount: ['', [Validators.required, Validators.min(0.01)]],
      taxAmount: [{value: '0.00', disabled: true}],
      finalAmount: ['', [Validators.required, Validators.min(0.01)]],
      expenseNote: [''],
      incomeNote: [''],
      isRefund: [false],
      isRecurring: [false],
      recurringInterval: ['Days'],
      repetitions: [''],
      paymentAmount: ['', [Validators.required, Validators.min(0.01)]],
      paidOn: [new Date().toISOString().slice(0, 16), Validators.required],
      paymentMethod: ['Cash', Validators.required],
      paymentAccount: ['', Validators.required],
      paymentNote: [''],
      // NEW: Add paymentStatus control
      paymentStatus: ['Paid']
    });

    this.expenseForm.get('type')?.valueChanges.subscribe(type => {
      this.expenseForm.get('expenseType')?.clearValidators();
      this.expenseForm.get('incomeType')?.clearValidators();
      this.expenseForm.get('expenseType')?.updateValueAndValidity();
      this.expenseForm.get('incomeType')?.updateValueAndValidity();
      this.generateReferenceNumber();
    });
  }

  onTypeChange() {
    this.expenseForm.patchValue({
      expenseCategory: '',
      incomeCategory: '',
      accountHead: '',
      expenseForContact: '',
      incomeForContact: ''
    });
    this.generateReferenceNumber();
  }

  onFileSelected(event: any) {
    const file = event.target.files[0];
    if (file) {
      const fileType = file.name.split('.').pop()?.toLowerCase();
      const fileSizeMB = file.size / (1024 * 1024);
      
      if (!this.allowedFileTypes.includes(fileType!)) {
        alert('Invalid file type. Allowed types: ' + this.allowedFileTypes.join(', '));
        event.target.value = '';
        return;
      }

      if (fileSizeMB > this.maxFileSizeMB) {
        alert('File size exceeds 5MB limit.');
        event.target.value = '';
        return;
      }

      this.selectedFile = file;
    }
  }

  getCustomerNameById(customerId: string): string {
    const customer = this.customers.find(c => c.id === customerId);
    if (customer) {
      return customer.businessName || `${customer.firstName} ${customer.lastName}`;
    }
    return '';
  }

  onExpenseCategoryChange() {
    const selectedCategoryId = this.expenseForm.get('expenseCategory')?.value;
    if (selectedCategoryId) {
      const selectedCategory = this.expenseCategories.find(cat => cat.id === selectedCategoryId);
      if (selectedCategory && selectedCategory.accountHead) {
        this.expenseForm.get('accountHead')?.setValue(selectedCategory.accountHead);
        this.expenseForm.get('accountHead')?.disable();
      }
    } else {
      this.expenseForm.get('accountHead')?.enable();
      this.expenseForm.get('accountHead')?.setValue('');
    }
  }

  onIncomeCategoryChange() {
    const selectedCategoryId = this.expenseForm.get('incomeCategory')?.value;
    if (selectedCategoryId) {
      const selectedCategory = this.incomeCategories.find(cat => cat.id === selectedCategoryId);
      if (selectedCategory && selectedCategory.accountHead) {
        this.expenseForm.get('accountHead')?.setValue(selectedCategory.accountHead);
        this.expenseForm.get('accountHead')?.disable();
      }
    } else {
      this.expenseForm.get('accountHead')?.enable();
      this.expenseForm.get('accountHead')?.setValue('');
    }
  }
  
  async saveExpense() {
    if (this.isSubmitting) return;

    this.markFormGroupTouched(this.expenseForm);
    if (!this.expenseForm.valid) {
      alert('Please fill in all required fields correctly.');
      return;
    }

    this.isSubmitting = true;
    const formData = this.expenseForm.getRawValue();

    try {
      if (formData.type === 'expense' && formData.paymentAccount) {
        const account = this.paymentAccounts.find(acc => acc.id === formData.paymentAccount);
        if (account && account.balance < parseFloat(formData.paymentAmount)) {
          const confirmProceed = confirm(
            `Insufficient balance in ${account.name}. Available: ₹${account.balance.toFixed(2)}, Required: ₹${parseFloat(formData.paymentAmount).toFixed(2)}\n\nThis may result in a negative balance. Do you want to proceed anyway?`
          );
          if (!confirmProceed) {
            this.isSubmitting = false;
            return;
          }
        }
      }

      let categoryName = '';
      if (formData.type === 'expense' && formData.expenseCategory) {
        const category = this.expenseCategories.find(cat => cat.id === formData.expenseCategory);
        categoryName = category?.categoryName || '';
      } else if (formData.type === 'income' && formData.incomeCategory) {
        const category = this.incomeCategories.find(cat => cat.id === formData.incomeCategory);
        categoryName = category?.categoryName || '';
      }

      const referenceNo = formData.referenceNo || this.autoGeneratedRefNo;

      const entryData = {
        type: formData.type,
        entryType: formData.type,
        businessLocation: formData.businessLocation,
        date: new Date(formData.date),
        paidOn: new Date(formData.paidOn),
        referenceNo: referenceNo,
        applicableTax: formData.applicableTax,
        taxAmount: parseFloat(formData.taxAmount || '0'),
        totalAmount: parseFloat(formData.totalAmount),
        finalAmount: parseFloat(formData.finalAmount),
        paymentAmount: parseFloat(formData.paymentAmount),
        paymentMethod: formData.paymentMethod,
        paymentAccount: formData.paymentAccount,
        paymentNote: formData.paymentNote,
        document: formData.document,
        accountHead: formData.accountHead,
        isRefund: formData.isRefund,
        isRecurring: formData.isRecurring,
        recurringInterval: formData.recurringInterval,
        repetitions: formData.repetitions,
        status: 'completed',
        addedBy: 'current-user-id', 
        addedByDisplayName: 'Current User',
        subCategory: '',
        // NEW: Add balance amount and payment status to saved data
        balanceAmount: this.balanceAmount,
        paymentStatus: this.paymentStatus,
        ...(formData.type === 'expense' ? {
          expenseCategory: formData.expenseCategory,
          expenseCategoryName: categoryName,
          expenseFor: formData.expenseFor,
          expenseForContact: formData.expenseForContact,
          expenseNote: formData.expenseNote,
          expenseType: formData.expenseType,
          incomeCategory: '',
          incomeFor: '',
          incomeForContact: '',
          incomeNote: '',
          incomeType: ''
        } : {
          incomeCategory: formData.incomeCategory,
          incomeCategoryName: categoryName,
          incomeFor: formData.incomeFor,
          incomeForContact: formData.incomeForContact,
          incomeNote: formData.incomeNote,
          incomeType: formData.incomeType,
          expenseCategory: '',
          expenseFor: '',
          expenseForContact: '',
          expenseNote: '',
          expenseType: ''
        })
      };
      
      if (formData.type === 'expense') {
        await this.expenseService.addExpense(entryData);
      } else {
        await this.expenseService.addIncome(entryData);
      }

      alert(`${formData.type === 'income' ? 'Income' : 'Expense'} saved successfully!`);
      this.resetForm();
      this.router.navigate(['/list-expenses']);
    } catch (error: any) {
      console.error('Error saving entry:', error);
      alert(error.message || 'An error occurred while saving. Please try again.');
    } finally {
      this.isSubmitting = false;
    }
  }

  async getSelectedAccountBalance(): Promise<number> {
    const accountId = this.expenseForm.get('paymentAccount')?.value;
    if (!accountId) return 0;
    
    return await this.accountService.getCalculatedBalance(accountId);
  }

  resetForm() {
    this.expenseForm.get('accountHead')?.enable();
    this.expenseForm.reset();
    this.selectedFile = null;
    // NEW: Reset balance and payment status
    this.balanceAmount = 0;
    this.paymentStatus = 'Paid';
    this.initForm();
    this.generateReferenceNumber();
    
    const fileInput = document.getElementById('document') as HTMLInputElement;
    if (fileInput) {
      fileInput.value = '';
    }
  }

  private markFormGroupTouched(formGroup: FormGroup) {
    Object.values(formGroup.controls).forEach(control => {
      control.markAsTouched();
      if (control instanceof FormGroup) {
        this.markFormGroupTouched(control);
      }
    });
  }

  hasError(fieldName: string): boolean {
    const field = this.expenseForm.get(fieldName);
    return !!(field && field.invalid && field.touched);
  }

  getErrorMessage(fieldName: string): string {
    const field = this.expenseForm.get(fieldName);
    if (field && field.errors && field.touched) {
      if (field.errors['required']) {
        return `${fieldName} is required`;
      }
      if (field.errors['min']) {
        return `${fieldName} must be greater than ${field.errors['min'].min}`;
      }
    }
    return '';
  }
}