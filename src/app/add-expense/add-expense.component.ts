import { Component, OnInit, OnDestroy } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { ExpenseService } from '../services/expense.service';
import { LocationService } from '../services/location.service';
import { ExpenseCategoriesService } from '../services/expense-categories.service';
import { UserService } from '../services/user.service';
import { CustomerService } from '../services/customer.service';
import { Router } from '@angular/router';
import { Subscription } from 'rxjs';
import { TaxService } from '../services/tax.service';
import { AccountService } from '../services/account.service';

@Component({
  selector: 'app-add-expense',
  templateUrl: './add-expense.component.html',
  styleUrls: ['./add-expense.component.scss']
})
export class AddExpenseComponent implements OnInit, OnDestroy {
  expenseForm!: FormGroup;
  maxFileSizeMB = 5;
  allowedFileTypes = ['pdf', 'csv', 'zip', 'doc', 'docx', 'jpeg', 'jpg', 'png'];
  selectedFile: File | null = null;
  businessLocations: any[] = [];
  taxRates: any[] = [];
  paymentAccounts: any[] = [];
  expenseCategories: any[] = [];
  incomeCategories: any[] = [];
  users: any[] = [];
  customers: any[] = [];
  accountHeads: any[] = [];
  
  private locationsSubscription: Subscription | undefined;
  private expenseCategoriesSubscription: Subscription | undefined;
  private incomeCategoriesSubscription: Subscription | undefined;
  private usersSubscription: Subscription | undefined;
  private customersSubscription: Subscription | undefined;
  
  autoGeneratedRefNo: string = '';
  displayRefNumber: string = '';
  isSubmitting: boolean = false; // Add loading state

  constructor(
    private fb: FormBuilder, 
    private expenseService: ExpenseService,
    private taxService: TaxService,
    private accountService: AccountService,
    private locationService: LocationService,
    private expenseCategoriesService: ExpenseCategoriesService,
    private userService: UserService,
    private customerService: CustomerService,
    private router: Router
  ) {}

  ngOnInit(): void {
    this.initForm(); // Initialize form first
    this.loadBusinessLocations();
    this.loadExpenseCategories();
    this.loadIncomeCategories();
    this.loadUsers();
    this.loadCustomers();
    this.loadTaxRates();
    this.loadPaymentAccounts();
    this.generateReferenceNumber();
    
    // Watch for reference number changes
    this.expenseForm.get('referenceNo')?.valueChanges.subscribe(value => {
      if (!value || value.trim() === '') {
        this.updateRefNumberPlaceholder();
      }
    });
    this.expenseForm.get('applicableTax')?.valueChanges.subscribe(taxName => {
  this.calculateTax();
});

this.expenseForm.get('totalAmount')?.valueChanges.subscribe(() => {
  this.calculateTax();
});
  }
calculateTax() {
  const taxName = this.expenseForm.get('applicableTax')?.value;
  const totalAmount = parseFloat(this.expenseForm.get('totalAmount')?.value);

  if (taxName && taxName !== 'None' && !isNaN(totalAmount)) {
    const selectedTax = this.taxRates.find(tax => tax.name === taxName);
    if (selectedTax) {
      const taxRate = parseFloat(selectedTax.rate) / 100;
      const taxAmount = totalAmount * taxRate;
      this.expenseForm.get('taxAmount')?.setValue(taxAmount.toFixed(2), { emitEvent: false });
      // Update total amount if needed (tax inclusive)
      // this.expenseForm.get('totalAmount')?.setValue((totalAmount + taxAmount).toFixed(2));
    }
  } else {
    this.expenseForm.get('taxAmount')?.setValue('0.00', { emitEvent: false });
  }
}
  ngOnDestroy() {
    if (this.locationsSubscription) this.locationsSubscription.unsubscribe();
    if (this.expenseCategoriesSubscription) this.expenseCategoriesSubscription.unsubscribe();
    if (this.incomeCategoriesSubscription) this.incomeCategoriesSubscription.unsubscribe();
    if (this.usersSubscription) this.usersSubscription.unsubscribe();
    if (this.customersSubscription) this.customersSubscription.unsubscribe();
  }

  loadUsers() {
    this.usersSubscription = this.userService.getUsers().subscribe(
      (users: any[]) => {
        this.users = users;
        console.log('Users loaded:', this.users);
      },
      (error: any) => console.error('Error loading users:', error)
    );
  }

  loadCustomers() {
    this.customersSubscription = this.customerService.getCustomers().subscribe(
      (customers: any[]) => {
        this.customers = customers.filter(customer => 
          customer.status === 'Active'
        );
        console.log('Customers loaded:', this.customers);
      },
      (error: any) => console.error('Error loading customers:', error)
    );
  }

  loadTaxRates() {
    this.taxService.getTaxRates().subscribe(
      (rates: any[]) => {
        this.taxRates = rates;
        console.log('Tax rates loaded:', this.taxRates);
      },
      (error: any) => console.error('Error loading tax rates:', error)
    );
  }
loadPaymentAccounts() {
  this.accountService.getAccounts((accounts: any[]) => {
    this.paymentAccounts = accounts.map(account => ({
      id: account.id,
      name: account.name,
      accountType: account.accountType,
      balance: account.balance || 0 // Add this line to include balance
    }));
    console.log('Payment accounts loaded:', this.paymentAccounts); // For debugging
  });
}

  loadBusinessLocations() {
    this.locationsSubscription = this.locationService.getLocations().subscribe(
      (data: any[]) => {
        this.businessLocations = data;
        console.log('Business locations loaded:', this.businessLocations);
      },
      (error: any) => console.error('Error loading business locations:', error)
    );
  }

  loadExpenseCategories() {
    this.expenseCategoriesSubscription = this.expenseCategoriesService.getExpenseCategories().subscribe(
      (data: any[]) => {
        this.expenseCategories = data;
        this.extractAccountHeads([...this.expenseCategories, ...this.incomeCategories]);
        console.log('Expense categories loaded:', this.expenseCategories);
      },
      (error: any) => console.error('Error loading expense categories:', error)
    );
  }

  loadIncomeCategories() {
    this.incomeCategoriesSubscription = this.expenseCategoriesService.getIncomeCategories().subscribe(
      (data: any[]) => {
        this.incomeCategories = data;
        this.extractAccountHeads([...this.expenseCategories, ...this.incomeCategories]);
        console.log('Income categories loaded:', this.incomeCategories);
      },
      (error: any) => console.error('Error loading income categories:', error)
    );
  }

  extractAccountHeads(categories: any[]) {
    const uniqueAccountHeadsSet = new Set<string>();
    
    categories.forEach(category => {
      if (category.accountHead && category.accountHead.trim() !== '') {
        uniqueAccountHeadsSet.add(category.accountHead);
      }
    });
    
    this.accountHeads = Array.from(uniqueAccountHeadsSet).map(head => ({
      value: head,
      name: head
    }));
  }

  generateReferenceNumber() {
    const date = new Date();
    const year = date.getFullYear().toString().slice(-2);
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    const random = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
    
    const typePrefix = this.expenseForm?.get('type')?.value === 'income' ? 'INC' : 'EXP';
    this.autoGeneratedRefNo = `${typePrefix}-${year}${month}${day}-${random}`;
    this.displayRefNumber = this.autoGeneratedRefNo;
    
    setTimeout(() => this.updateRefNumberPlaceholder(), 100);
  }
  
  updateRefNumberPlaceholder() {
    const refNoInput = document.getElementById('referenceNo') as HTMLInputElement;
    if (refNoInput) {
      refNoInput.placeholder = this.autoGeneratedRefNo;
    }
  }

  initForm(): void {
    this.expenseForm = this.fb.group({
      type: ['expense', Validators.required],
      businessLocation: ['', Validators.required],
      expenseCategory: [''],
      incomeCategory: [''],
          taxAmount: [{value: '0.00', disabled: true}], // Add this line

      subCategory: [''],
      expenseType: [''],
      incomeType: [''],
      accountHead: [''],
      referenceNo: [''],
      date: [new Date().toISOString().slice(0, 16), Validators.required],
      expenseFor: [''],
      incomeFor: [''],
      expenseForContact: [''],
      incomeForContact: [''],
      document: [null],
      applicableTax: ['None'],
      totalAmount: ['', [Validators.required, Validators.min(0.01)]],
      expenseNote: [''],
      incomeNote: [''],
      isRefund: [false],
      isRecurring: [false],
      recurringInterval: ['Days'],
      repetitions: [''],
      paymentAmount: ['', [Validators.required, Validators.min(0.01)]],
      paidOn: [new Date().toISOString().slice(0, 16), Validators.required],
      paymentMethod: ['Cash', Validators.required],
    paymentAccount: ['', Validators.required], // Make payment account required
      paymentNote: ['']
    });

    // Set conditional validators based on type
    this.expenseForm.get('type')?.valueChanges.subscribe(type => {
      // Clear previous validators
      this.expenseForm.get('expenseType')?.clearValidators();
      this.expenseForm.get('incomeType')?.clearValidators();
      
      // Set new validators based on type
      if (type === 'expense') {
        // Remove required validator for income type when expense is selected
      } else if (type === 'income') {
        // Remove required validator for expense type when income is selected
      }
      
      this.expenseForm.get('expenseType')?.updateValueAndValidity();
      this.expenseForm.get('incomeType')?.updateValueAndValidity();
      this.generateReferenceNumber();
    });
  }

  onTypeChange() {
    // Reset category selection when type changes
    this.expenseForm.patchValue({
      expenseCategory: '',
      incomeCategory: '',
      accountHead: '',
      expenseForContact: '',
      incomeForContact: ''
    });
    this.generateReferenceNumber();
  }

  onFileSelected(event: any) {
    const file = event.target.files[0];
    if (file) {
      const fileType = file.name.split('.').pop()?.toLowerCase();
      const fileSizeMB = file.size / (1024 * 1024);
      
      if (!this.allowedFileTypes.includes(fileType!)) {
        alert('Invalid file type. Allowed types: ' + this.allowedFileTypes.join(', '));
        event.target.value = ''; // Clear the input
        return;
      }

      if (fileSizeMB > this.maxFileSizeMB) {
        alert('File size exceeds 5MB limit.');
        event.target.value = ''; // Clear the input
        return;
      }

      this.selectedFile = file;
      console.log('File selected:', this.selectedFile);
    }
  }

  getCustomerNameById(customerId: string): string {
    const customer = this.customers.find(c => c.id === customerId);
    if (customer) {
      return customer.businessName || `${customer.firstName} ${customer.lastName}`;
    }
    return '';
  }
// Add this method to your component
onExpenseCategoryChange() {
  const selectedCategoryId = this.expenseForm.get('expenseCategory')?.value;
  if (selectedCategoryId) {
    const selectedCategory = this.expenseCategories.find(cat => cat.id === selectedCategoryId);
    if (selectedCategory && selectedCategory.accountHead) {
      this.expenseForm.get('accountHead')?.setValue(selectedCategory.accountHead);
      this.expenseForm.get('accountHead')?.disable(); // Make it read-only
    }
  } else {
    this.expenseForm.get('accountHead')?.enable(); // Enable if no category selected
    this.expenseForm.get('accountHead')?.setValue('');
  }
}

// Add this method for income category as well if needed
onIncomeCategoryChange() {
  const selectedCategoryId = this.expenseForm.get('incomeCategory')?.value;
  if (selectedCategoryId) {
    const selectedCategory = this.incomeCategories.find(cat => cat.id === selectedCategoryId);
    if (selectedCategory && selectedCategory.accountHead) {
      this.expenseForm.get('accountHead')?.setValue(selectedCategory.accountHead);
      this.expenseForm.get('accountHead')?.disable(); // Make it read-only
    }
  } else {
    this.expenseForm.get('accountHead')?.enable(); // Enable if no category selected
    this.expenseForm.get('accountHead')?.setValue('');
  }
}
async saveExpense() {
  if (this.isSubmitting) return;

  this.markFormGroupTouched(this.expenseForm);
  if (!this.expenseForm.valid) {
    alert('Please fill in all required fields correctly.');
    return;
  }

  this.isSubmitting = true;
  const formData = this.expenseForm.getRawValue();

  try {
    // Prepare the data to save
    const dataToSave = {
      ...formData,
      referenceNo: formData.referenceNo || this.autoGeneratedRefNo,
      addedBy: 'current-user-id',
      addedByDisplayName: 'Current User',
      taxAmount: parseFloat(formData.taxAmount || '0'),
      date: new Date(formData.date).toISOString(),
      paidOn: new Date(formData.paidOn).toISOString(),
      paymentAmount: parseFloat(formData.paymentAmount),
      totalAmount: parseFloat(formData.totalAmount),
      status: 'completed'
    };

    // Validate payment account
    if (formData.paymentAccount) {
      const account = this.paymentAccounts.find(acc => acc.id === formData.paymentAccount);
      if (!account) {
        throw new Error('Selected payment account not found');
      }

      // Only check balance for expenses, not for incomes
      if (formData.type === 'expense') {
        const currentBalance = account.balance || 0;
        const paymentAmount = parseFloat(formData.paymentAmount);

        if (currentBalance < paymentAmount) {
          const confirmProceed = confirm(
            `Insufficient balance in ${account.name}. Available: ${currentBalance}, Required: ${paymentAmount}\n\nDo you want to proceed anyway?`
          );
          
          if (!confirmProceed) {
            throw new Error('Transaction cancelled by user');
          }
        }
      }
    }

    // Save to Firestore and get doc reference or string
    let docResponse: any;
    if (formData.type === 'income') {
      docResponse = await this.expenseService.addIncome(dataToSave);
    } else {
      docResponse = await this.expenseService.addExpense(dataToSave);
    }

    // Handle both possible return types: string or DocumentReference
    let docId: string;
    if (typeof docResponse === 'string') {
      docId = docResponse;
    } else if ('id' in docResponse) {
      docId = docResponse.id;
    } else {
      throw new Error('Unexpected response from addIncome/addExpense');
    }

    // Update account balance
    if (formData.paymentAccount) {
      try {
        await this.accountService.updateAccountBalance(
          formData.paymentAccount,
          formData.type === 'income' ? dataToSave.paymentAmount : -dataToSave.paymentAmount
        );
      } catch (updateError) {
        console.error('Account balance update failed:', updateError);
        // Rollback the transaction
        if (formData.type === 'income') {
          await this.expenseService.deleteIncome(docId);
        } else {
          await this.expenseService.deleteExpense(docId);
        }
        throw new Error('Transaction failed. Please try again.');
      }
    }

    alert(`${formData.type === 'income' ? 'Income' : 'Expense'} saved successfully!`);
    this.resetForm();
    this.router.navigate(['/list-expenses']);
  } catch (error: any) {
    console.error('Error saving entry:', error);
    if (error.message !== 'Transaction cancelled by user') {
      alert(error.message || 'An error occurred while saving. Please try again.');
    }
  } finally {
    this.isSubmitting = false;
  }
}


  getSelectedAccountBalance(): number {
  const accountId = this.expenseForm.get('paymentAccount')?.value;
  if (!accountId) return 0;
  
  const account = this.paymentAccounts.find(acc => acc.id === accountId);
  return account ? account.balance : 0;
}
resetForm() {
  this.expenseForm.get('accountHead')?.enable(); // Enable the field before reset
  this.expenseForm.reset();
  this.selectedFile = null;
  this.initForm();
  this.generateReferenceNumber();
  
  // Clear file input
  const fileInput = document.getElementById('document') as HTMLInputElement;
  if (fileInput) {
    fileInput.value = '';
  }
}

  private markFormGroupTouched(formGroup: FormGroup) {
    Object.values(formGroup.controls).forEach(control => {
      control.markAsTouched();
      if (control instanceof FormGroup) {
        this.markFormGroupTouched(control);
      }
    });
  }

  getFormValidationErrors(): any {
    const formErrors: any = {};
    Object.keys(this.expenseForm.controls).forEach(key => {
      const controlErrors = this.expenseForm.get(key)?.errors;
      if (controlErrors) {
        formErrors[key] = controlErrors;
      }
    });
    return formErrors;
  }

  // Helper method to check if a field has errors and is touched
  hasError(fieldName: string): boolean {
    const field = this.expenseForm.get(fieldName);
    return !!(field && field.invalid && field.touched);
  }

  // Helper method to get error message for a field
  getErrorMessage(fieldName: string): string {
    const field = this.expenseForm.get(fieldName);
    if (field && field.errors && field.touched) {
      if (field.errors['required']) {
        return `${fieldName} is required`;
      }
      if (field.errors['min']) {
        return `${fieldName} must be greater than ${field.errors['min'].min}`;
      }
    }
    return '';
  }
}