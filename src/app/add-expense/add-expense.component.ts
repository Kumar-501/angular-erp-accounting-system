import { Component, OnInit, OnDestroy } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { LocationService } from '../services/location.service';
import { ExpenseCategoriesService } from '../services/expense-categories.service';
import { UserService } from '../services/user.service';
import { CustomerService } from '../services/customer.service';
import { Router } from '@angular/router';
import { Subscription } from 'rxjs';
import { TaxService } from '../services/tax.service';
import { AccountService } from '../services/account.service';
import { ExpenseService } from '../services/expense.service';
import { Firestore } from '@angular/fire/firestore';
import { getCalculatedAccountBalance } from '../services/independent.service';

@Component({
  selector: 'app-add-expense',
  templateUrl: './add-expense.component.html',
  styleUrls: ['./add-expense.component.scss']
})
export class AddExpenseComponent implements OnInit, OnDestroy {
  expenseForm!: FormGroup;
  maxFileSizeMB = 5;
  allowedFileTypes = ['pdf', 'csv', 'zip', 'doc', 'docx', 'jpeg', 'jpg', 'png'];
  selectedFile: File | null = null;
  businessLocations: any[] = [];
  taxRates: any[] = [];
  paymentAccounts: any[] = [];
  expenseCategories: any[] = [];
  incomeCategories: any[] = [];
  users: any[] = [];
  customers: any[] = [];
  accountHeads: any[] = [];
  
  private locationsSubscription: Subscription | undefined;
  private expenseCategoriesSubscription: Subscription | undefined;
  private incomeCategoriesSubscription: Subscription | undefined;
  private usersSubscription: Subscription | undefined;
  private customersSubscription: Subscription | undefined;
    autoGeneratedRefNo: string = '';
  displayRefNumber: string = '';
  isSubmitting: boolean = false; // Add loading state
  
  constructor(
    private fb: FormBuilder, 
    private taxService: TaxService,
    private accountService: AccountService,
    private expenseService: ExpenseService,
    private locationService: LocationService,
    private expenseCategoriesService: ExpenseCategoriesService,
    private userService: UserService,
    private customerService: CustomerService,
    private router: Router,
    private firestore: Firestore
  ) {}

  ngOnInit(): void {
    this.initForm(); // Initialize form first
    this.loadBusinessLocations();
    this.loadExpenseCategories();
    this.loadIncomeCategories();
    this.loadUsers();
    this.loadCustomers();
    this.loadTaxRates();
    this.loadPaymentAccounts();
    this.generateReferenceNumber();
    
    // Watch for reference number changes
    this.expenseForm.get('referenceNo')?.valueChanges.subscribe(value => {
      if (!value || value.trim() === '') {
        this.updateRefNumberPlaceholder();
      }
    });
    this.expenseForm.get('applicableTax')?.valueChanges.subscribe(taxName => {
  this.calculateTax();
});

this.expenseForm.get('totalAmount')?.valueChanges.subscribe(() => {
  this.calculateTax();
});
  }
calculateTax() {
  const taxName = this.expenseForm.get('applicableTax')?.value;
  const totalAmount = parseFloat(this.expenseForm.get('totalAmount')?.value);

  if (taxName && taxName !== 'None' && !isNaN(totalAmount)) {
    const selectedTax = this.taxRates.find(tax => tax.name === taxName);
    if (selectedTax) {
      const taxRate = parseFloat(selectedTax.rate) / 100;
      const taxAmount = totalAmount * taxRate;
      this.expenseForm.get('taxAmount')?.setValue(taxAmount.toFixed(2), { emitEvent: false });
      // Update total amount if needed (tax inclusive)
      // this.expenseForm.get('totalAmount')?.setValue((totalAmount + taxAmount).toFixed(2));
    }
  } else {
    this.expenseForm.get('taxAmount')?.setValue('0.00', { emitEvent: false });
  }
}
  ngOnDestroy() {
    if (this.locationsSubscription) this.locationsSubscription.unsubscribe();
    if (this.expenseCategoriesSubscription) this.expenseCategoriesSubscription.unsubscribe();
    if (this.incomeCategoriesSubscription) this.incomeCategoriesSubscription.unsubscribe();
    if (this.usersSubscription) this.usersSubscription.unsubscribe();
    if (this.customersSubscription) this.customersSubscription.unsubscribe();
  }

  loadUsers() {
    this.usersSubscription = this.userService.getUsers().subscribe(
      (users: any[]) => {
        this.users = users;
        console.log('Users loaded:', this.users);
      },
      (error: any) => console.error('Error loading users:', error)
    );
  }

  loadCustomers() {
    this.customersSubscription = this.customerService.getCustomers().subscribe(
      (customers: any[]) => {
        this.customers = customers.filter(customer => 
          customer.status === 'Active'
        );
        console.log('Customers loaded:', this.customers);
      },
      (error: any) => console.error('Error loading customers:', error)
    );
  }

  loadTaxRates() {
    this.taxService.getTaxRates().subscribe(
      (rates: any[]) => {
        this.taxRates = rates;
        console.log('Tax rates loaded:', this.taxRates);
      },
      (error: any) => console.error('Error loading tax rates:', error)
    );
  }
async loadPaymentAccounts(): Promise<void> {
  this.accountService.getAccounts(async (accounts: any[]) => {
    // Calculate balance for each account using the independent function
    const accountsWithCalculatedBalance = await Promise.all(
      accounts.map(async (account) => {
        const calculatedBalance = await getCalculatedAccountBalance(this.firestore, account.id);
        return {
          id: account.id,
          name: account.name,
          accountType: account.accountType,
          balance: calculatedBalance
        };
      })
    );
    
    this.paymentAccounts = accountsWithCalculatedBalance;
    console.log('Payment accounts loaded with calculated balances:', this.paymentAccounts);
  });
}

  loadBusinessLocations() {
    this.locationsSubscription = this.locationService.getLocations().subscribe(
      (data: any[]) => {
        this.businessLocations = data;
        console.log('Business locations loaded:', this.businessLocations);
      },
      (error: any) => console.error('Error loading business locations:', error)
    );
  }

  loadExpenseCategories() {
    this.expenseCategoriesSubscription = this.expenseCategoriesService.getExpenseCategories().subscribe(
      (data: any[]) => {
        this.expenseCategories = data;
        this.extractAccountHeads([...this.expenseCategories, ...this.incomeCategories]);
        console.log('Expense categories loaded:', this.expenseCategories);
      },
      (error: any) => console.error('Error loading expense categories:', error)
    );
  }

  loadIncomeCategories() {
    this.incomeCategoriesSubscription = this.expenseCategoriesService.getIncomeCategories().subscribe(
      (data: any[]) => {
        this.incomeCategories = data;
        this.extractAccountHeads([...this.expenseCategories, ...this.incomeCategories]);
        console.log('Income categories loaded:', this.incomeCategories);
      },
      (error: any) => console.error('Error loading income categories:', error)
    );
  }

  extractAccountHeads(categories: any[]) {
    const uniqueAccountHeadsSet = new Set<string>();
    
    categories.forEach(category => {
      if (category.accountHead && category.accountHead.trim() !== '') {
        uniqueAccountHeadsSet.add(category.accountHead);
      }
    });
    
    this.accountHeads = Array.from(uniqueAccountHeadsSet).map(head => ({
      value: head,
      name: head
    }));
  }

  generateReferenceNumber() {
    const date = new Date();
    const year = date.getFullYear().toString().slice(-2);
    const month = (date.getMonth() + 1).toString().padStart(2, '0');
    const day = date.getDate().toString().padStart(2, '0');
    const random = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
    
    const typePrefix = this.expenseForm?.get('type')?.value === 'income' ? 'INC' : 'EXP';
    this.autoGeneratedRefNo = `${typePrefix}-${year}${month}${day}-${random}`;
    this.displayRefNumber = this.autoGeneratedRefNo;
    
    setTimeout(() => this.updateRefNumberPlaceholder(), 100);
  }
  
  updateRefNumberPlaceholder() {
    const refNoInput = document.getElementById('referenceNo') as HTMLInputElement;
    if (refNoInput) {
      refNoInput.placeholder = this.autoGeneratedRefNo;
    }
  }

  initForm(): void {
    this.expenseForm = this.fb.group({
      type: ['expense', Validators.required],
      businessLocation: ['', Validators.required],
      expenseCategory: [''],
      incomeCategory: [''],
          taxAmount: [{value: '0.00', disabled: true}], // Add this line

      subCategory: [''],
      expenseType: [''],
      incomeType: [''],
      accountHead: [''],
      referenceNo: [''],
      date: [new Date().toISOString().slice(0, 16), Validators.required],
      expenseFor: [''],
      incomeFor: [''],
      expenseForContact: [''],
      incomeForContact: [''],
      document: [null],
      applicableTax: ['None'],
      totalAmount: ['', [Validators.required, Validators.min(0.01)]],
      expenseNote: [''],
      incomeNote: [''],
      isRefund: [false],
      isRecurring: [false],
      recurringInterval: ['Days'],
      repetitions: [''],
      paymentAmount: ['', [Validators.required, Validators.min(0.01)]],
      paidOn: [new Date().toISOString().slice(0, 16), Validators.required],
      paymentMethod: ['Cash', Validators.required],
    paymentAccount: ['', Validators.required], // Make payment account required
      paymentNote: ['']
    });

    // Set conditional validators based on type
    this.expenseForm.get('type')?.valueChanges.subscribe(type => {
      // Clear previous validators
      this.expenseForm.get('expenseType')?.clearValidators();
      this.expenseForm.get('incomeType')?.clearValidators();
      
      // Set new validators based on type
      if (type === 'expense') {
        // Remove required validator for income type when expense is selected
      } else if (type === 'income') {
        // Remove required validator for expense type when income is selected
      }
      
      this.expenseForm.get('expenseType')?.updateValueAndValidity();
      this.expenseForm.get('incomeType')?.updateValueAndValidity();
      this.generateReferenceNumber();
    });
  }

  onTypeChange() {
    // Reset category selection when type changes
    this.expenseForm.patchValue({
      expenseCategory: '',
      incomeCategory: '',
      accountHead: '',
      expenseForContact: '',
      incomeForContact: ''
    });
    this.generateReferenceNumber();
  }

  onFileSelected(event: any) {
    const file = event.target.files[0];
    if (file) {
      const fileType = file.name.split('.').pop()?.toLowerCase();
      const fileSizeMB = file.size / (1024 * 1024);
      
      if (!this.allowedFileTypes.includes(fileType!)) {
        alert('Invalid file type. Allowed types: ' + this.allowedFileTypes.join(', '));
        event.target.value = ''; // Clear the input
        return;
      }

      if (fileSizeMB > this.maxFileSizeMB) {
        alert('File size exceeds 5MB limit.');
        event.target.value = ''; // Clear the input
        return;
      }

      this.selectedFile = file;
      console.log('File selected:', this.selectedFile);
    }
  }

  getCustomerNameById(customerId: string): string {
    const customer = this.customers.find(c => c.id === customerId);
    if (customer) {
      return customer.businessName || `${customer.firstName} ${customer.lastName}`;
    }
    return '';
  }
// Add this method to your component
onExpenseCategoryChange() {
  const selectedCategoryId = this.expenseForm.get('expenseCategory')?.value;
  if (selectedCategoryId) {
    const selectedCategory = this.expenseCategories.find(cat => cat.id === selectedCategoryId);
    if (selectedCategory && selectedCategory.accountHead) {
      this.expenseForm.get('accountHead')?.setValue(selectedCategory.accountHead);
      this.expenseForm.get('accountHead')?.disable(); // Make it read-only
    }
  } else {
    this.expenseForm.get('accountHead')?.enable(); // Enable if no category selected
    this.expenseForm.get('accountHead')?.setValue('');
  }
}

// Add this method for income category as well if needed
onIncomeCategoryChange() {
  const selectedCategoryId = this.expenseForm.get('incomeCategory')?.value;
  if (selectedCategoryId) {
    const selectedCategory = this.incomeCategories.find(cat => cat.id === selectedCategoryId);
    if (selectedCategory && selectedCategory.accountHead) {
      this.expenseForm.get('accountHead')?.setValue(selectedCategory.accountHead);
      this.expenseForm.get('accountHead')?.disable(); // Make it read-only
    }
  } else {
    this.expenseForm.get('accountHead')?.enable(); // Enable if no category selected
    this.expenseForm.get('accountHead')?.setValue('');
  }
}
async saveExpense() {
  if (this.isSubmitting) return;

  this.markFormGroupTouched(this.expenseForm);
  if (!this.expenseForm.valid) {
    alert('Please fill in all required fields correctly.');
    return;
  }

  this.isSubmitting = true;
  const formData = this.expenseForm.getRawValue();

  try {
    // Validate payment account using independent function
    if (formData.paymentAccount) {
      const account = this.paymentAccounts.find(acc => acc.id === formData.paymentAccount);
      if (!account) {
        throw new Error('Selected payment account not found');
      }

      // Only check balance for expenses, not for incomes
      if (formData.type === 'expense') {
        // Get real-time calculated balance
        const currentBalance = await getCalculatedAccountBalance(this.firestore, formData.paymentAccount);
        const paymentAmount = parseFloat(formData.paymentAmount);

        if (currentBalance < paymentAmount) {
          const confirmProceed = confirm(
            `Insufficient balance in ${account.name}. Available: ₹${currentBalance.toFixed(2)}, Required: ₹${paymentAmount.toFixed(2)}\n\nDo you want to proceed anyway?`
          );
          
          if (!confirmProceed) {
            throw new Error('Transaction cancelled by user');
          }
        }
      }
    }

    // Get category name for description
    let categoryName = '';
    if (formData.type === 'expense' && formData.expenseCategory) {
      const category = this.expenseCategories.find(cat => cat.id === formData.expenseCategory);
      categoryName = category?.categoryName || '';
    } else if (formData.type === 'income' && formData.incomeCategory) {
      const category = this.incomeCategories.find(cat => cat.id === formData.incomeCategory);
      categoryName = category?.categoryName || '';
    }

    // Generate reference number if not provided
    const referenceNo = formData.referenceNo || this.autoGeneratedRefNo;

    // Prepare the income/expense data for the respective collection
    const entryData = {
      type: formData.type,
      entryType: formData.type,
      businessLocation: formData.businessLocation,
      date: new Date(formData.date),
      paidOn: new Date(formData.paidOn),
      referenceNo: referenceNo,
      applicableTax: formData.applicableTax,
      taxAmount: parseFloat(formData.taxAmount || '0'),
      totalAmount: parseFloat(formData.totalAmount),
      paymentAmount: parseFloat(formData.paymentAmount),
      paymentMethod: formData.paymentMethod,
      paymentAccount: formData.paymentAccount,
      paymentNote: formData.paymentNote,
      document: formData.document,
      accountHead: formData.accountHead,
      isRefund: formData.isRefund,
      isRecurring: formData.isRecurring,
      recurringInterval: formData.recurringInterval,
      repetitions: formData.repetitions,
      status: 'completed',
      addedBy: 'current-user-id', // Replace with actual user ID
      addedByDisplayName: 'Current User', // Replace with actual user display name
      subCategory: '',
      // Type-specific fields
      ...(formData.type === 'expense' ? {
        expenseCategory: formData.expenseCategory,
        expenseCategoryName: categoryName, // Add category name for transactions
        expenseFor: formData.expenseFor,
        expenseForContact: formData.expenseForContact,
        expenseNote: formData.expenseNote,
        expenseType: formData.expenseType,
        // Empty income fields
        incomeCategory: '',
        incomeFor: '',
        incomeForContact: '',
        incomeNote: '',
        incomeType: ''
      } : {
        incomeCategory: formData.incomeCategory,
        incomeCategoryName: categoryName, // Add category name for transactions
        incomeFor: formData.incomeFor,
        incomeForContact: formData.incomeForContact,
        incomeNote: formData.incomeNote,
        incomeType: formData.incomeType,
        // Empty expense fields
        expenseCategory: '',
        expenseFor: '',
        expenseForContact: '',
        expenseNote: '',
        expenseType: ''
      })
    };// Save to the appropriate collection (expenses or incomes)
    // The ExpenseService will handle both the collection entry and transaction creation
    if (formData.type === 'expense') {
      await this.expenseService.addExpense(entryData);
    } else {
      await this.expenseService.addIncome(entryData);
    }

    alert(`${formData.type === 'income' ? 'Income' : 'Expense'} saved successfully!`);
    this.resetForm();
    this.router.navigate(['/list-expenses']);
  } catch (error: any) {
    console.error('Error saving entry:', error);
    if (error.message !== 'Transaction cancelled by user') {
      alert(error.message || 'An error occurred while saving. Please try again.');
    }
  } finally {
    this.isSubmitting = false;
  }
}

async getSelectedAccountBalance(): Promise<number> {
  const accountId = this.expenseForm.get('paymentAccount')?.value;
  if (!accountId) return 0;
  
  return await getCalculatedAccountBalance(this.firestore, accountId);
}

// Add helper method to get calculated balance for any account
async getAccountBalance(accountId: string): Promise<number> {
  return await getCalculatedAccountBalance(this.firestore, accountId);
}

  resetForm() {
    this.expenseForm.get('accountHead')?.enable(); // Enable the field before reset
    this.expenseForm.reset();
    this.selectedFile = null;
    this.initForm();
    this.generateReferenceNumber();
    
    // Clear file input
    const fileInput = document.getElementById('document') as HTMLInputElement;
    if (fileInput) {
      fileInput.value = '';
    }
  }

  private markFormGroupTouched(formGroup: FormGroup) {
    Object.values(formGroup.controls).forEach(control => {
      control.markAsTouched();
      if (control instanceof FormGroup) {
        this.markFormGroupTouched(control);
      }
    });
  }

  getFormValidationErrors(): any {
    const formErrors: any = {};
    Object.keys(this.expenseForm.controls).forEach(key => {
      const controlErrors = this.expenseForm.get(key)?.errors;
      if (controlErrors) {
        formErrors[key] = controlErrors;
      }
    });
    return formErrors;
  }

  // Helper method to check if a field has errors and is touched
  hasError(fieldName: string): boolean {
    const field = this.expenseForm.get(fieldName);
    return !!(field && field.invalid && field.touched);
  }

  // Helper method to get error message for a field
  getErrorMessage(fieldName: string): string {
    const field = this.expenseForm.get(fieldName);
    if (field && field.errors && field.touched) {
      if (field.errors['required']) {
        return `${fieldName} is required`;
      }
      if (field.errors['min']) {
        return `${fieldName} must be greater than ${field.errors['min'].min}`;
      }
    }
    return '';
  }
}